# 整体架构

HighPerformance-KVStore 采用单线程 Reactor 模型，结合 Epoll ET 实现高性能网络 IO 和事件驱动调度。

## 架构概览

整体流程：

1. 服务器启动，创建监听 socket，设置为非阻塞
2. 初始化 `Epoller`，将监听 fd 注册到 epoll
3. 进入主事件循环：
   - 调用 `epoll_wait` 获取就绪事件
   - 根据不同 fd 类型（监听 / 连接）分发处理：
     - 监听 fd 可读：接受新连接，创建 `Connection` 并注册到 epoll
     - 已有连接 fd 可读：读取数据，放入读缓冲区，交给协议解析
     - 已有连接 fd 可写：从写缓冲区发送响应数据
4. 主循环中定期轮询 / 检查定时器，剔除长时间空闲的连接
5. 接收到 `SIGINT` 等信号时：
   - 触发 KVStore 快照保存
   - 关闭所有连接和监听 fd
   - 程序优雅退出

## 关键设计点

- **单线程 Reactor**：  
  通过事件驱动 + 非阻塞 IO，在单线程内完成所有连接的管理和处理逻辑，降低上下文切换开销。

- **Epoll ET 模式**：  
  使用边缘触发提高 epoll 事件通知效率，需要配合“循环读 / 写直到 EAGAIN”保证数据读写完整。

- **应用层缓冲区**：  
  为每个 `Connection` 维护独立的读写缓冲区，解决 TCP 粘包 / 拆包问题，并支持半包缓存。

- **自定义协议 + 状态机解析**：  
  将网络字节流转换为高层命令（如 `GET` / `SET`），通过状态机避免一次系统调用无法读完整命令时出现解析错误。

- **KVStore + 持久化**：  
  使用 `std::map` 存储键值数据，支持启动时加载快照文件、退出前保存快照，保证崩溃恢复能力。

## 与 Redis 的相似之处

- 单线程事件循环
- 基于 epoll 的 IO 多路复用
- 使用 KV 模型进行数据存取
- 提供快照式持久化能力

虽然功能上远不及 Redis 完整，但在网络模型和存储核心路径上做了一个“轻量级的学习版实现”。
